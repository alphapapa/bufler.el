#+TITLE: sbuffer

#+PROPERTY: LOGGING nil

# Note: This readme works with the org-make-toc <https://github.com/alphapapa/org-make-toc> package, which automatically updates the table of contents.

#+HTML: <a href=https://alphapapa.github.io/dont-tread-on-emacs/><img src="images/dont-tread-on-emacs-150.png" align="right"></a>

# [[https://melpa.org/#/package-name][file:https://melpa.org/packages/sbuffer-badge.svg]] [[https://stable.melpa.org/#/package-name][file:https://stable.melpa.org/packages/sbuffer-badge.svg]]

Sbuffer is like Ibuffer, but using [[https://github.com/magit/magit][magit-section]] to group buffers in a very flexible way.

* Screenshots

This screenshot shows group faces themed by [[https://github.com/alphapapa/prism.el][prism]], which Sbuffer optionally supports.

[[images/screenshot.png]]

In the default Emacs theme:

[[images/default-theme.png]]

# * Contents                                                         :noexport:
# :PROPERTIES:
# :TOC:      :include siblings
# :END:
# :CONTENTS:
#   -  [[#installation][Installation]]
#   -  [[#usage][Usage]]
#   -  [[#changelog][Changelog]]
#   -  [[#credits][Credits]]
#   -  [[#development][Development]]
#   -  [[#license][License]]
# :END:

* Installation
:PROPERTIES:
:TOC:      :depth 0
:END:

Use [[https://github.com/quelpa/quelpa-use-package][quelpa-use-package]], like this:

#+BEGIN_SRC elisp
  (use-package sbuffer
    :quelpa (sbuffer :fetcher github :repo "alphapapa/sbuffer.el"))
#+END_SRC

# ** MELPA
# 
# If you installed from MELPA, you're done.  Just run one of the commands below.
# 
# ** Manual
# 
#   Install these required packages:
# 
#   + =foo=
#   + =bar=
# 
#   Then put this file in your load-path, and put this in your init file:
# 
#   #+BEGIN_SRC elisp
# (require 'sbuffer)
#   #+END_SRC

* Usage
:PROPERTIES:
:TOC:      :depth 0
:END:

  Run the command =sbuffer=.  You can customize settings in the =sbuffer= group.

** Bindings

In the Sbuffer buffer, these keys are available (use =C-h m= to get the most up-to-date listing).  They operate on all buffers in the section at point.

+  =1= -- =4= Cycle section levels at point.
+  =M-1= -- =M-4= Cycle top-level sections.
+  =g=  Refresh Sbuffer list.
+  =RET=  Pop to buffer.
+  =k=  Kill buffers.
+  =s=  Save buffers.

** Defining groups

/See the =sbuffer= info page to view this information in Emacs./

The Sbuffer groups definition is a list stored in variable =sbuffer-groups=.  Each element of the list is either a lambda function which takes a single argument, a buffer, or a list of such functions.  Each buffer is matched against these functions in order until it does not match any more functions at that level.  A list of functions defines a subgroup which short-circuits other groups at the same level, preventing further grouping outside of the subgroup's functions.  Ultimately, it's lambdas all the way down.

This seems somewhat difficult to explain, so please see the examples.  Once you get the hang of it, it's powerful and flexible.

For convenience, the macro =sbuffer-defgroups= provides a sort of DSL, a concise vocabulary for defining groups.  For example, the default groups are defined like this:

#+BEGIN_SRC elisp
  (sbuffer-defgroups
    (group
     ;; Subgroup collecting all `help-mode' and `info-mode' buffers.
     (group-or "*Help/Info*"
               (mode-match "*Help*" (rx bos "help-"))
               (mode-match "*Info*" (rx bos "info-"))))
    (group
     ;; Subgroup collecting all special buffers (i.e. ones that are not
     ;; file-backed), except `magit-status-mode' buffers (which are allowed to fall
     ;; through to other groups, so they end up grouped with their project buffers).
     (group-and "*Special*"
                (lambda (buffer)
                  (unless (or (funcall (mode-match "Magit" (rx bos "magit-status"))
                                       buffer)
                              (funcall (auto-file) buffer))
                    "*Special*")))
     (group
      ;; Subgroup collecting these "special special" buffers
      ;; separately for convenience.
      (name-match "**Special**"
                  (rx bos "*" (or "Messages" "Warnings" "scratch" "Backtrace") "*")))
     (group
      ;; Subgroup collecting all other Magit buffers, grouped by directory.
      (mode-match "*Magit* (non-status)" (rx bos (or "magit" "forge") "-"))
      (auto-directory))
     ;; Subgroup for Helm buffers.
     (mode-match "*Helm*" (rx bos "helm-"))
     ;; Remaining special buffers are grouped automatically by mode.
     (auto-mode))
    ;; All buffers under "~/.emacs.d" (or wherever it is).
    (dir user-emacs-directory)
    (group
     ;; Subgroup collecting buffers in `org-directory' (or "~/org" if
     ;; `org-directory' is not yet defined).
     (dir (if (bound-and-true-p org-directory)
              org-directory
            "~/org"))
     (group
      ;; Subgroup collecting indirect Org buffers, grouping them by file.
      ;; This is very useful when used with `org-tree-to-indirect-buffer'.
      (auto-indirect)
      (auto-file))
     ;; Group remaining buffers by whether they're file backed, then by mode.
     (group-not "*special*" (auto-file))
     (auto-mode))
    (group
     ;; Subgroup collecting buffers in a version-control project,
     ;; grouping them by directory and then major mode.
     (auto-project) (auto-mode))
    ;; Group remaining buffers by directory, then major mode.
    (auto-directory)
    (auto-mode))
#+END_SRC

*Note* that the macro does not /set/ the variable =sbuffer-groups=, it merely expands a groups form, so you should use, e.g. ~(setf sbuffer-groups (sbuffer-defgroups ...))~ to actually set the groups.

The following group types are available in =sbuffer-defgroups=.  Note that each one is expanded into a lambda, so they may also be called by =funcall= (see example above).

+  Meta types :: These types compose multiple of the other types into a single group.
     -  ~group (TYPE...)~ Define a subgroup matching given types, which short-circuits other groups at the same level.
     -  ~group-not (NAME TYPE)~ Groups buffers which do /not/ match the given type.
     -  ~group-and (NAME TYPE...)~ Groups buffers which match all of the given types.
     -  ~group-or (NAME TYPE...)~  Groups buffers which match any of the given types.
+  Auto-types :: These types automatically create groups for the buffer's attribute of this type.
     -  ~auto-directory~  Buffer's directory.
     -  ~auto-file~  Buffer's file name.
     -  ~auto-hidden~  Whether the buffer is hidden.
     -  ~auto-indirect~  Whether the buffer is indirect (e.g. a cloned indirect buffer).
     -  ~auto-mode~  Buffer's major mode.
     -  ~auto-project~  Buffer's version-control project directory according to ~project.el~.
     -  ~auto-special~  Whether the buffer is special (i.e. whether its name starts with ~*~).
     -  ~auto-tramp~  Whether the buffer is opened via Tramp.
+  Regexp types :: These types match a value against a buffer's attribute and group buffers which match.
     -  ~name-match (NAME REGEXP)~ Match a regular expression against the buffer's name.
     -  ~mode-match (NAME REGEXP)~ Match a regular expression against the buffer's major-mode.
+  Other types ::
     -  ~dir (DIRS DEPTH)~  Groups buffers which match one of the given DIRS.  DIRS may be one or a list of directory paths.  DEPTH may be nil or a depth above which to produce subdirectory groups (a feature probably broken at the moment).  See example above.

* Changelog

** 0.1

First tagged release.

* Credits

+  Thanks to [[https://github.com/tarsius][Jonas Bernoulli]] for [[https://github.com/magit/magit/blob/master/lisp/magit-section.el][magit-section]].
+  Thanks to [[https://github.com/magnars/dash.el][Magnar Sveen]] and [[https://github.com/Fuco1][Matus Goljer]] for [[https://github.com/magnars/dash.el][dash.el]].
+  Thanks to [[https://github.com/rejeep][Johan Andersson]] for [[https://github.com/rejeep/f.el][f.el]].

* Development

Bug reports, feature requests, suggestions â€” /oh my/!

* License

GPLv3

* COMMENT Export Setup                                             :noexport:
:PROPERTIES:
:TOC:      :ignore (this descendants)
:END:

# Much borrowed from Org's =org-manual.org=.

#+OPTIONS: broken-links:t *:t

** Info export options

#+TEXINFO_DIR_CATEGORY: Emacs
#+TEXINFO_DIR_TITLE: Sbuffer: (sbuffer)
#+TEXINFO_DIR_DESC: Like Ibuffer, with flexible grouping in hierarchical sections

# NOTE: We could use these, but that causes a pointless error, "org-compile-file: File "..README.info" wasn't produced...", so we just rename the files in the after-save-hook instead.
# #+TEXINFO_FILENAME: sbuffer.info
# #+EXPORT_FILE_NAME: sbuffer.texi

** File-local variables

# NOTE: Setting org-comment-string buffer-locally is a nasty hack to work around GitHub's org-ruby's HTML rendering, which does not respect noexport tags.  The only way to hide this tree from its output is to use the COMMENT keyword, but that prevents Org from processing the export options declared in it.  So since these file-local variables don't affect org-ruby, wet set org-comment-string to an unused keyword, which prevents Org from deleting this tree from the export buffer, which allows it to find the export options in it.  And since org-export does respect the noexport tag, the tree is excluded from the info page.

# Local Variables:
# before-save-hook: org-make-toc
# after-save-hook: (lambda nil (when (and (require 'ox-texinfo nil t) (org-texinfo-export-to-info)) (delete-file "README.texi") (rename-file "README.info" "sbuffer.info" t)))
# org-export-initial-scope: buffer
# org-comment-string: "NOTCOMMENT"
# End:

